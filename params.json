{
  "name": "Fluxweb",
  "tagline": "react+flux前端组件式开发框架",
  "body": "# fluxweb\r\nreact+flux+browserify前端组件式开发框架，基于上述三大框架做了工程化和约定俗成的封装，屏蔽了显式的调用过程，使开发人员专注于组件及其业务逻辑的开发。\r\n## 写在前面\r\n### React\r\nReact是一个JavaScript框架，用于构建“可预期的”和“声明式的”Web用户界面，它已经使Facebook更快地开发Web应用。\r\n可通过Facebook的github网址了解详情：\r\n[http://facebook.github.io/react/](http://facebook.github.io/react/ \"\")\r\n### Flux\r\nFlux 是一个Facebook开发的、利用单向数据流实现的应用架构，用于 React。\r\nFlux应用有四个主要的部分组成：调度(Dispatcher)、存储(Store)、动作(Action)和视图(React)。\r\nFacebook工程经理Tom Occhino说，由于他们“非常巨大”的代码库和庞大的组织，因而需要“以某种方式使代码结构化，使其更加可预测”。\r\n这已经通过 Flux 和 React 完成。\r\nFlux是一个系统架构，用于推进应用中的数据单向流动。\r\n可通过Facebook的github网址了解详情：\r\n[http://facebook.github.io/flux/](http://facebook.github.io/flux/ \"\")\r\n### Browserify\r\nBrowserify 可以让你使用类似于 node 的 require() 的方式来组织浏览器端的 Javascript 代码，通过预编译让前端 javascript 可以直接使用 node npm 安装的一些库。\r\n\r\n安装：\r\n```\r\nnpm install -g browserify\r\n```\r\n这是 main.js 的内容，像普通的 nodejs 程序那样使用 require() 加载库和文件：\r\n```\r\nvar foo = require('./foo.js');\r\nvar bar = require('../lib/bar.js');\r\nvar gamma = require('gamma');\r\nvar elem = document.getElementById('result');\r\nvar x = foo(100) + bar('baz');\r\nelem.textContent = gamma(x);\r\n```\r\n导出的方法：\r\n```\r\nmodule.exports = function (n) { return n * 111 }\r\n```\r\n使用 browserify 编译：\r\n```\r\n$ browserify main.js > bundle.js\r\n```\r\n现在 main.js 需要的所有其它文件都会被编译进 bundle.js 中，包括很多层 require() 的情况也会一起被递归式的编译过来。\r\n\r\n编译好的 js 可以直接拿到浏览器使用\r\n```\r\n<script src=\"bundle.js\"></script>\r\n```\r\n因此，框架采用Browserify的模块化方式组织我们的javascript代码，进一步提高了代码的可维护性和可测试性，后面将结合nodeunit模块详细介绍如何进行js模块的单元测试\r\n## 构建/运行依赖\r\n1. node.js - server-side JS engine\r\n2. npm - node package manager\r\n\r\n## node,npm安装说明\r\nnode.js - [https://github.com/nodejs/node](https://github.com/nodejs/node)\r\n\r\nnpm - [https://github.com/npm/npm](https://github.com/npm/npm)\r\n(npm在最近的node.js发布系列版中已加入，不需要单独安装)\r\n## fluxweb安装说明\r\n运行以下命令：\r\n```\r\ngit clone https://github.com/yb030832/fluxweb.git\r\ncd fluxweb\r\nnpm install\r\n```\r\n## 一个例子\r\n### 1. 创建页面\r\n/public/index.html\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title></title>\r\n    <!--sourcecss begin-->\r\n    <link rel=\"stylesheet/less\" type=\"text/css\" href=\"stylesheets/less/index.less\"/>\r\n    <script type=\"text/javascript\" src=\"javascripts/vendor/less/less.min.js\"></script>\r\n    <!--sourcecss end-->\r\n</head>\r\n<body>\r\n<div id=\"container\"></div>\r\n</body>\r\n</html>\r\n<!--sourcejs begin-->\r\n<script type=\"text/javascript\" src=\"javascripts/bundle.js\"></script>\r\n<!--sourcejs end-->\r\n```\r\n以上是初始页面的基本结构，其中&lt;!--sourcecss ...--&gt;，&lt;!--sourcejs ...--&gt;标签是页面预编译参数，不能省略，\r\n在正式编译后，此类标签内的脚本或样式将被编译后版本替换。\r\n显然，框架样式是基于less开发的，因此引入了less样式文件以及less编译脚本，bundle.js是未压缩版本的broswerify合并文件，将在编译时被压缩。\r\n编译后的页面结构如下：\r\n\r\n/dist/public/index.html\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title></title>\r\n    <link rel=\"stylesheet/css\" type=\"text/css\" href=\"stylesheets/all.css\"/>\r\n</head>\r\n<body>\r\n<div id=\"container\"></div>\r\n</body>\r\n</html>\r\n<script type=\"text/javascript\" src=\"javascripts/bundle.min.js\"></script>\r\n```\r\n### 2.创建样式\r\n/public/stylesheets/less/index.less\r\n```\r\n@baseBackgroundColor:#ffffff;\r\n@width:100%;\r\n@height:100%;\r\nhtml,body{\r\n  width:@width;\r\n  height:@height;\r\n  overflow:hidden;\r\n}\r\n#container{\r\n  width:@width;\r\n  height:@height;\r\n  background-color:@baseBackgroundColor;\r\n}\r\n```\r\n### 3.创建存储(Store)\r\n/public/javascripts/stores/IndexStore.js\r\n```\r\nvar Flux = require('../vendor/util/FluxUtil');\r\nvar resultText=\"\";\r\nvar IndexStore = Flux.createStore({\r\n    //更新存储结果，update为约定函数名，必须实现\r\n    update:function(action) {\r\n        var text = action.text.trim();\r\n        switch(action.actionType) {\r\n            case \"updateText\"://注册updateText动作处理逻辑\r\n                if (text !== '') {\r\n                    resultText=text;\r\n                }\r\n                break;\r\n            default:\r\n            // no op\r\n        }\r\n    },\r\n    //获取存储结果，getResultText为自定义函数名，可选实现\r\n    //一般来说,至少有一个getSomething函数,以便获取存储数据\r\n    getResultText: function() {\r\n        return resultText;\r\n    }\r\n});\r\nmodule.exports = IndexStore;\r\n```\r\n### 4.创建动作(Action)\r\n/public/javascripts/actions/IndexAction.js\r\n```\r\nvar Flux = require('../vendor/util/FluxUtil');\r\nvar IndexAction = Flux.createAction({\r\n    //发起更新动作，updateText为自定义函数名，可选实现\r\n    //一般来说,至少有一个updateSomething函数,以便发起动作\r\n    updateText: function(text) {\r\n        //广播更新动作，所有的Store都将接收到\r\n        this.dispatch(\"updateText\",text);\r\n    }\r\n});\r\nmodule.exports = IndexAction;\r\n```\r\n注意：通常，我们在发起一个动作的时候，会跟服务端进行数据传输，\r\n比如发送一个ajax请求，我们也是在Action的updateSomething方法中去实现，\r\n并在请求返回时dispatch出去，\r\nStore只负责存放最后的结果和结果运算,不负责前后端通讯。\r\n### 5.创建视图(React)\r\n/public/javascripts/components/Index.js\r\n```\r\nvar Flux = require('../vendor/util/FluxUtil');\r\nvar FluxConstant=require(\"../vendor/util/FluxConstant\");\r\nvar React = require('react');\r\nvar IndexStore = require('../stores/IndexStore');\r\nvar IndexAction = require('../actions/IndexAction');\r\nvar Index = Flux.createView({\r\n    //获取当前视图所需Store,如果用到了Store,必须实现该方法，否则将无法响应状态更新\r\n    getStore: function(){\r\n        return [IndexStore];\r\n    },\r\n    //获取当前视图状态，通常都是从Store中获取\r\n    getState: function(){\r\n        return {text: LoginStore.getResultText()};\r\n    },\r\n    //发起一个动作，此例为点击事件发起\r\n    handleClick:function(){\r\n        IndexAction.updateText(\"this is my first update\");\r\n    },\r\n    //视图渲染，发生状态变化时自动调用\r\n    render: function() {\r\n        return (\r\n            <div>\r\n               <label>{this.state.text}</label>\r\n               <button onClick={this.handleClick}></button>\r\n            </div>\r\n     },\r\n     //尺寸重绘，发生窗体大小变化时自动调用\r\n     resize: function() {\r\n         //获取当前页面的尺寸\r\n         var width=FluxConstant.view.PAGE_WIDTH;\r\n         var height=FluxConstant.view.PAGE_HEIGHT;\r\n     }\r\n});\r\nmodule.exports = Index;\r\n```\r\n### 6.调用视图\r\n/public/app.js\r\n```\r\nvar Jquery=require('./vendor/jquery/jquery-1.9.1');\r\n//应用node模块\r\nvar React = require('react');\r\nvar ReactDOM = require('react-dom');\r\nvar ContainerMain=require('./components/container/main');\r\nvar Index=require('./components/Index');\r\n//渲染初始页面\r\nReactDOM.render(\r\n    <Index/>,\r\n    document.getElementById('container')\r\n);\r\n```\r\n### 7.启动本地HTTP服务\r\n通过框架安装的node express开启一个http服务来测试例子：\r\n~~~\r\nnode ./bin/www\r\n~~~\r\n### 8.编译并启动文件监控\r\n启动框架已配置的grunt任务编译代码，并开始文件监控，下次我们再修改代码，就能自动编译啦！\r\n~~~\r\ngrunt monitor\r\n~~~\r\n注意在Window开发环境下，不要关闭Shell，Linux开发环境下可通过nohup命令在后台运行:)\r\n\r\nOK，访问http://localhost:3000来看看结果吧！\r\n## 文档\r\n想要了解更多关于如何编译打包web应用的信息,如下所示:\r\n\r\n* [如何编译打包工程](https://github.com/yb030832/fluxweb/wiki/%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E5%B7%A5%E7%A8%8B)\r\n\r\n进入我们的[Wiki](https://github.com/yb030832/fluxweb/wiki)可了解更多\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}